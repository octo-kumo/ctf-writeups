---
ai_date: 2025-04-27 05:17:22
ai_summary: Common Modulus Attack used to recover the flag after RSA encryption with shared modulus
ai_tags:
  - rsa
  - common-modulus
  - recovery
created: 2024-07-19T22:35
points: 100
solves: 172
tags:
  - rsa
  - modulus
updated: 2025-07-14T09:46
---

We can observe that the same `flag` is encrypted twice using RSA, with the same modulus `n` and two different `e`.

This means we can employ **Common Modulus Attack**.

> If a single plaintext has been encrypted to two ciphertexts by keys with the same modulus but different exponent, this plaintext can be recovered if `gcd(e1, e2) = 1` and `gcd(ct2, n) = 1`.

```python
from pqdm.threads import pqdm
from math import gcd
import string
from Crypto.Util.number import long_to_bytes

n = 10564138776494961592014999649037456550575382342808603854749436027195501416732462075688995673939606183123561300630136824493064895936898026009104455605012656112227514866064565891419378050994219942479391748895230609700734689313646635542548646360048189895973084184133523557171393285803689091414097848899969143402526024074373298517865298596472709363144493360685098579242747286374667924925824418993057439374115204031395552316508548814416927671149296240291698782267318342722947218349127747750102113632548814928601458613079803549610741586798881477552743114563683288557678332273321812700473448697037721641398720563971130513427
ct = 5685838967285159794461558605064371935808577614537313517284872621759307511347345423871842021807700909863051421914284950799996213898176050217224786145143140975344971261417973880450295037249939267766501584938352751867637557804915469126317036843468486184370942095487311164578774645833237405496719950503828620690989386907444502047313980230616203027489995981547158652987398852111476068995568458186611338656551345081778531948372680570310816660042320141526741353831184185543912246698661338162113076490444675190068440073174561918199812094602565237320537343578057719268260605714741395310334777911253328561527664394607785811735
signature = 1275844821761484983821340844185575393419792337993640612766980471786977428905226540853335720384123385452029977656072418163973282187758615881752669563780394774633730989087558776171213164303749873793794423254467399925071664163215290516803252776553092090878851242467651143197066297392861056333834850421091466941338571527809879833005764896187139966615733057849199417410243212949781433565368562991243818187206912462908282367755241374542822443478131348101833178421826523712810049110209083887706516764828471192354631913614281317137232427617291828563280573927573115346417103439835614082100305586578385614623425362545483289428

# referenced https://github.com/maximmasiutin/rsa-common-modulus/blob/main/rsa-common-modulus.py


def modinv(a, m):
    return pow(a, -1, m)


def attack(c1, c2, e1, e2, N):
    g = gcd(e1, e2)
    s1 = modinv(e1, e2)
    s2 = (g - e1 * s1) // e2
    temp = modinv(c2, N)
    m1 = pow(c1, s1, N)
    m2 = pow(temp, -s2, N)
    r1 = (m1 * m2) % N
    return r1


def process(e2):
    M_recovered = long_to_bytes(attack(ct, signature, 65537, e2, n))
    if all([c in string.printable.encode() for c in M_recovered]):
        print("found!!")
        print(M_recovered)
        exit()
    return 0

# loop through every possible value of the 16 bit crc
result = pqdm(range(1, 65536), process, n_jobs=16)
```

```flag
ictf{oops_i_leaked_some_info}
```